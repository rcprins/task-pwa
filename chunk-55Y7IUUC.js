import{Ba as J,C as $,D as O,E as V,Eb as W,I as F,K as G,O as X,Ob as Z,P as Y,Q as I,R as _,S as T,V as z,e as j,g as f,j as R,l as m,la as H,m as C,n as K,r as M,vb as Q}from"./chunk-JYJ6DCPQ.js";var N=class{constructor(a,e){this.dbService=a;this.local_db_table_name=e;window.addEventListener("online",()=>{this.handleOnline()})}entityChanges$=new R(void 0);handleOnline(){return console.log("Syncing after getting online again '"+navigator.onLine+"'"),this.updateLocalDB()}watchEntities(){return this.entityChanges$.asObservable()}updateLocalDB(){let a=[];this.getAllRemoteInternal().subscribe(e=>{this.dbService.getAll(this.local_db_table_name).subscribe(r=>{e.forEach(t=>{t.id&&(r.find(n=>n.id==t.id)||(console.log("pushing entity: "+t.id),a.push(t)))}),this.dbService.bulkAdd(this.local_db_table_name,a).subscribe(()=>(console.log("Local tasks updated with the result of the remote tasks update."),this.entityChanges$.next(a),this.getAllLocal()))})})}getByIdLocal(a){return C(this.dbService.getByID(this.local_db_table_name,a))}getById(a){return this.getByIdLocal(a).pipe($(void 0),F(e=>{if(e!==void 0)return K(e);debugger;return this.getByIdRemote(a).pipe(G(r=>this.add(r)))}))}add(a){return a.synced=!1,this.dbService.add(this.local_db_table_name,a)}update(a){return console.log("Updating local entity with id:'"+a.id+"' in local store"),a.synced=!1,this.dbService.update(this.local_db_table_name,a)}deleteEntity(a){if(!a.id)throw Error("Cannot delete enyity as it has has no id");let e=this.dbService.delete(this.local_db_table_name,a.id);return e.subscribe({next:()=>console.log("Delete success"),error:r=>console.error("Delete error",r)}),e}getAllRemote(){return this.updateLocalDB(),this.getAllLocal()}getAllLocal(){return this.dbService.getAll(this.local_db_table_name)}getAll(){return navigator.onLine?this.getAllRemote():this.getAllLocal()}};var x=function(o){return o.readonly="readonly",o.readwrite="readwrite",o}(x||{}),ee=new I(null),te=new I("Indexed DB"),ie=new I("Server Indexed DB");function se(o,a){return o.objectStoreNames.contains(a)}function S(o,a,e){if(!o){e("You need to use the openDatabase function to create a database before you query it!");return}se(o,a)||e(`objectStore does not exists: ${a}`)}function v(o,a){let e=o.transaction(a.storeName,a.dbMode);return e.onerror=a.error,e.onabort=a.abort,e}function D(o,a,e,r){return{storeName:a,dbMode:o,error:t=>{e(t)},abort:t=>{e(t)}}}var E=[];function b(o,a,e,r){return new Promise((t,n)=>{o||n("IndexedDB not available");let i=o.open(a,e),c;i.onsuccess=()=>{c=i.result,E.push(c),t(c)},i.onerror=()=>{n(`IndexedDB error: ${i.error}`)},typeof r=="function"&&(i.onupgradeneeded=s=>{r(s,c)})})}function k(o,a,e,r,t){return j(this,null,function*(){return new Promise((n,i)=>{if(!o)return;let c=o.open(a,e);c.onupgradeneeded=s=>j(this,null,function*(){let l=s.target.result,p=r.map(h=>j(this,null,function*(){if(!l.objectStoreNames.contains(h.store)){let u=l.createObjectStore(h.store,h.storeConfig);for(let g of h.storeSchema)u.createIndex(g.name,g.keypath,g.options)}}));yield Promise.all(p);let d=t&&t();if(d){let h=Object.keys(d).map(u=>parseInt(u,10)).filter(u=>u>s.oldVersion).sort((u,g)=>u-g);for(let u of h)d[u](l,c.transaction)}l.close(),n()}),c.onsuccess=s=>{s.target.result.close(),n()},c.onerror=s=>{i(s)}})})}function ae(o,a,e){if(!o||!a||!e)throw Error('Params: "dbName", "version", "storeName" are mandatory.');return new f(r=>{try{let t=a+1,n=indexedDB.open(o,t);n.onupgradeneeded=i=>{let c=i.target.result;c.deleteObjectStore(e),c.close(),console.log("onupgradeneeded"),r.next(),r.complete()},n.onerror=i=>r.error(i)}catch(t){r.error(t)}})}function ce(o){return new Promise((a,e)=>{if(!o){e(new Error("No database to close"));return}try{o.close(),a()}catch(r){e(`Error closing database: ${r}`)}})}function y(){return function(o,a,e){let r=e.value;return e.value=function(...t){let n=r.apply(this,t);return n instanceof f?n.pipe(V(()=>j(this,null,function*(){let i=E.map(c=>j(this,null,function*(){yield ce(c)}));yield Promise.all(i),E.length=0}))):n},e}}var le=(()=>{class o{constructor(e,r){this.dbConfigs=e,this.indexedDB=r,this.defaultDatabaseName=null,Object.values(this.dbConfigs).forEach((t,n,i)=>this.instanciateConfig(t,i.length===1))}instanciateConfig(e,r){return j(this,null,function*(){if(!e.name)throw new Error("NgxIndexedDB: Please, provide the dbName in the configuration");if((e.isDefault??!1)&&this.defaultDatabaseName)throw new Error("NgxIndexedDB: Only one database can be set as default");((e.isDefault??!1)&&!this.defaultDatabaseName||r)&&(this.defaultDatabaseName=e.name,this.selectedDb=e.name),yield k(this.indexedDB,e.name,e.version,e.objectStoresMeta,e.migrationFactory),b(this.indexedDB,e.name).then(t=>{t.version!==e.version&&(Q()&&(console.warn(`
            Your DB Config doesn't match the most recent version of the DB with name ${e.name}, please update it
            DB current version: ${t.version};
            Your configuration: ${e.version};
            `),console.warn(`Using latest version ${t.version}`)),this.dbConfigs[e.name].version=t.version),t.close()})})}get dbConfig(){return this.dbConfigs[this.selectedDb]}getDatabaseVersion(){return new f(e=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(r=>{e.next(r.version),e.complete()}).catch(r=>e.error(`error during get version of database => ${r} `))})}selectDb(e){if(e=e??this.defaultDatabaseName,!e)throw new Error("No database name specified and no default database set.");if(!Object.keys(this.dbConfigs).includes(e))throw new Error(`NgxIndexedDB: Database ${e} is not initialized.`);this.selectedDb=e}createObjectStore(e,r){return j(this,null,function*(){let t=[e];yield k(this.indexedDB,this.dbConfig.name,++this.dbConfig.version,t,r)})}createDynamicObjectStore(e,r){return j(this,null,function*(){let t=[e];yield k(this.indexedDB,this.dbConfig.name,this.dbConfig.version,t,r)})}add(e,r,t){return new f(n=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(i=>{let s=v(i,D(x.readwrite,e,d=>n.error(d))).objectStore(e),p=!!t?s.add(r,t):s.add(r);p.onsuccess=d=>j(this,null,function*(){let h=d.target.result,u=s.get(h);u.onsuccess=g=>{n.next(g.target.result),n.complete()},u.onerror=g=>{n.error(g)}}),p.onerror=d=>{n.error(d)}}).catch(i=>n.error(i))})}bulkAdd(e,r){let t=new Promise((n,i)=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(c=>{let l=v(c,D(x.readwrite,e,n,i)).objectStore(e),p=r.map(d=>new Promise(h=>{let u=d.key;delete d.key;let B=!!u?l.add(d,u):l.add(d);B.onsuccess=A=>{let oe=A.target.result;h(oe)}}));n(Promise.all(p))}).catch(c=>i(c))});return C(t)}bulkDelete(e,r){let t=r.map(n=>new Promise((i,c)=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(s=>{let l=v(s,D(x.readwrite,e,c,i));l.objectStore(e).delete(n),l.oncomplete=()=>{this.getAll(e).pipe(O(1)).subscribe(d=>{i(d)})}}).catch(s=>c(s))}));return C(Promise.all(t))}getByKey(e,r){return new f(t=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{let s=v(n,D(x.readonly,e,t.error)).objectStore(e).get(r);s.onsuccess=l=>{t.next(l.target.result),t.complete()},s.onerror=l=>{t.error(l)}}).catch(n=>t.error(n))})}bulkGet(e,r){let t=r.map(n=>this.getByKey(e,n));return new f(n=>{M(t).subscribe(i=>{n.next(i),n.complete()})})}getByID(e,r){return new f(t=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{S(n,e,l=>t.error(l));let s=v(n,D(x.readonly,e,t.error,t.next)).objectStore(e).get(r);s.onsuccess=l=>{t.next(l.target.result)}}).catch(n=>t.error(n))})}getByIndex(e,r,t){return new f(n=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(i=>{S(i,e,d=>n.error(d));let p=v(i,D(x.readonly,e,n.error)).objectStore(e).index(r).get(t);p.onsuccess=d=>{n.next(d.target.result),n.complete()}}).catch(i=>n.error(i))})}getAll(e){return new f(r=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{S(t,e,s=>r.error(s));let c=v(t,D(x.readonly,e,r.error,r.next)).objectStore(e).getAll();c.onerror=s=>{r.error(s)},c.onsuccess=({target:{result:s}})=>{r.next(s),r.complete()}}).catch(t=>r.error(t))})}update(e,r){return new f(t=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{S(n,e,l=>t.error(l));let c=v(n,D(x.readwrite,e,l=>t.error(l))).objectStore(e),s=c.put(r);s.onsuccess=l=>j(this,null,function*(){let p=l.target.result,d=c.get(p);d.onsuccess=h=>{t.next(h.target.result),t.complete()}})}).catch(n=>t.error(n))})}bulkPut(e,r){let t;return new f(n=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(i=>{S(i,e,s=>n.error(s)),t=v(i,D(x.readwrite,e,s=>n.error(s)));let c=t.objectStore(e);r.forEach((s,l)=>{let p=c.put(s);l===r.length-1&&(p.onsuccess=d=>{t.commit(),n.next(d.target.result),n.complete()}),p.onerror=d=>{t.abort(),n.error(d)}})}).catch(i=>{t?.abort(),n.error(i)})})}delete(e,r){return new f(t=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{S(n,e,s=>t.error(s));let i=v(n,D(x.readwrite,e,s=>t.error(s)));i.objectStore(e).delete(r),i.onerror=s=>t.error(s),i.oncomplete=()=>{this.getAll(e).pipe(O(1)).subscribe({next:s=>{t.next(s)},error:s=>t.error(s),complete:()=>t.complete()})}}).catch(n=>t.error(n))})}deleteByKey(e,r){return new f(t=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{S(n,e,s=>t.error(s));let i=v(n,D(x.readwrite,e,s=>t.error(s)));i.objectStore(e).delete(r),i.onerror=s=>t.error(s),i.oncomplete=()=>{t.next(),t.complete()}}).catch(n=>t.error(n))})}deleteAllByIndex(e,r,t,n){return new f(i=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(c=>{S(c,e,h=>i.error(h));let d=v(c,D(x.readwrite,e,i.error)).objectStore(e).index(r).openCursor(t,n);d.onerror=h=>i.error(h),d.onsuccess=h=>{let u=h.target.result;u?(u.delete(),u.continue()):(i.next(),i.complete())}}).catch(c=>i.error(c))})}clear(e){return new f(r=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(t=>{S(t,e,c=>r.error(c));let n=v(t,D(x.readwrite,e,c=>r.error(c)));n.objectStore(e).clear(),n.onerror=c=>r.error(c),n.oncomplete=()=>{r.next(),r.complete()}}).catch(t=>r.error(t))})}deleteDatabase(){return new f(e=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(r=>j(this,null,function*(){r.close();let t=this.indexedDB.deleteDatabase(this.dbConfig.name);t.onsuccess=()=>{e.next(),e.complete()},t.onerror=n=>e.error(n),t.onblocked=()=>{console.warn("Delete blocked: Ensure all tabs, instances, or connections are closed. Database name:",this.dbConfig.name),e.error(new Error("Unable to delete database because it's blocked"))}})).catch(r=>e.error(r))})}openCursor(e){let{storeName:r,query:t,direction:n,mode:i=x.readonly}=e;return new f(c=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(s=>{S(s,r,h=>c.error(h));let l=v(s,D(i,r,c.error)),d=l.objectStore(r).openCursor(t,n);l.oncomplete=()=>c.complete(),d.onerror=h=>c.error(h),d.onsuccess=h=>{let u=h.target.result;u&&c.next(u)}}).catch(s=>c.error(s))})}openCursorByIndex(e){let{storeName:r,indexName:t,query:n,direction:i,mode:c=x.readonly}=e;return new f(s=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(l=>{S(l,r,g=>s.error(g));let p=v(l,D(c,r,s.error)),u=p.objectStore(r).index(t).openCursor(n,i);p.oncomplete=()=>s.complete(),u.onerror=g=>s.error(g),u.onsuccess=g=>{let B=g.target.result;B&&s.next(B)}}).catch(l=>s.error(l))})}getAllByIndex(e,r,t,n){return new f(i=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(c=>{S(c,e,u=>i.error(u));let d=v(c,D(x.readonly,e,i.error)).objectStore(e).index(r).openCursor(t,n),h=[];d.onerror=u=>i.error(u),d.onsuccess=u=>{let g=u.target.result;g?(h.push(g.value),g.continue()):(i.next(h),i.complete())}}).catch(c=>i.error(c))})}getAllKeysByIndex(e,r,t,n){return new f(i=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(c=>{S(c,e,u=>i.error(u));let p=v(c,D(x.readonly,e,i.error)).objectStore(e).index(r),d=[],h=p.openKeyCursor(t,n);h.onerror=u=>i.error(u),h.onsuccess=u=>{let g=u.target.result;if(g){let{primaryKey:B,key:A}=g;d.push({primaryKey:B,key:A}),g.continue()}else i.next(d),i.complete()}}).catch(c=>i.error(c))})}count(e,r){return new f(t=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(n=>{S(n,e,l=>t.error(l));let s=v(n,D(x.readonly,e,t.error)).objectStore(e).count(r);s.onerror=l=>t.error(l),s.onsuccess=l=>{t.next(l.target.result),t.complete()}}).catch(n=>t.error(n))})}countByIndex(e,r,t){return new f(n=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(i=>{S(i,e,d=>n.error(d));let p=v(i,D(x.readonly,e,n.error)).objectStore(e).index(r).count(t);p.onerror=d=>n.error(d),p.onsuccess=d=>{n.next(d.target.result),n.complete()}}).catch(i=>n.error(i))})}deleteObjectStore(e){return ae(this.dbConfig.name,++this.dbConfig.version,e)}getAllObjectStoreNames(){return new f(e=>{b(this.indexedDB,this.dbConfig.name,this.dbConfig.version).then(r=>{e.next(Array.from(r.objectStoreNames)),e.complete()}).catch(r=>e.error(r))})}static{this.\u0275fac=function(r){return new(r||o)(_(ee),_(te))}}static{this.\u0275prov=X({token:o,factory:o.\u0275fac})}}return m([y()],o.prototype,"getDatabaseVersion",null),m([y()],o.prototype,"add",null),m([y()],o.prototype,"bulkAdd",null),m([y()],o.prototype,"bulkDelete",null),m([y()],o.prototype,"getByKey",null),m([y()],o.prototype,"bulkGet",null),m([y()],o.prototype,"getByID",null),m([y()],o.prototype,"getByIndex",null),m([y()],o.prototype,"getAll",null),m([y()],o.prototype,"update",null),m([y()],o.prototype,"bulkPut",null),m([y()],o.prototype,"delete",null),m([y()],o.prototype,"deleteByKey",null),m([y()],o.prototype,"deleteAllByIndex",null),m([y()],o.prototype,"clear",null),m([y()],o.prototype,"deleteDatabase",null),m([y()],o.prototype,"openCursor",null),m([y()],o.prototype,"openCursorByIndex",null),m([y()],o.prototype,"getAllByIndex",null),m([y()],o.prototype,"getAllKeysByIndex",null),m([y()],o.prototype,"count",null),m([y()],o.prototype,"countByIndex",null),m([y()],o.prototype,"getAllObjectStoreNames",null),o})(),q=class{cmp(){return 0}databases(){return Promise.resolve([])}deleteDatabase(){return{onupgradeneeded:null,onblocked:null,onerror:null,onsuccess:null,error:null}}open(){return{onupgradeneeded:null,onblocked:null,onerror:null,onsuccess:null,error:null}}};function re(){z(re);let o=T(H),a=T(ie,{optional:!0})??new q;return Z(o)?T(W).defaultView.indexedDB:a}var de=(...o)=>{let a=o.reduce((e,r)=>(e[r.name]=r,e),{});return[le,{provide:ee,useValue:a},{provide:te,useFactory:re}]},Te=(()=>{class o{static forRoot(...e){return{ngModule:o,providers:[...de(...e)]}}static{this.\u0275fac=function(r){return new(r||o)}}static{this.\u0275mod=J({type:o})}static{this.\u0275inj=Y({})}}return o})();var ue=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),L={randomUUID:ue};var P,he=new Uint8Array(16);function U(){if(!P){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");P=crypto.getRandomValues.bind(crypto)}return P(he)}var w=[];for(let o=0;o<256;++o)w.push((o+256).toString(16).slice(1));function ne(o,a=0){return(w[o[a+0]]+w[o[a+1]]+w[o[a+2]]+w[o[a+3]]+"-"+w[o[a+4]]+w[o[a+5]]+"-"+w[o[a+6]]+w[o[a+7]]+"-"+w[o[a+8]]+w[o[a+9]]+"-"+w[o[a+10]]+w[o[a+11]]+w[o[a+12]]+w[o[a+13]]+w[o[a+14]]+w[o[a+15]]).toLowerCase()}function pe(o,a,e){if(L.randomUUID&&!a&&!o)return L.randomUUID();o=o||{};let r=o.random??o.rng?.()??U();if(r.length<16)throw new Error("Random bytes length must be >= 16");if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,a){if(e=e||0,e<0||e+16>a.length)throw new RangeError(`UUID byte range ${e}:${e+15} is out of buffer bounds`);for(let t=0;t<16;++t)a[e+t]=r[t];return a}return ne(r)}var ge=pe;export{N as a,le as b,Te as c,ge as d};
